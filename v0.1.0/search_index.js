var documenterSearchIndex = {"docs":
[{"location":"#GeometricFilter.jl","page":"GeometricFilter.jl","title":"GeometricFilter.jl","text":"","category":"section"},{"location":"","page":"GeometricFilter.jl","title":"GeometricFilter.jl","text":"The aim of this package is to allow to perform filtering for dynamical systems on manifold, in particular homogeneous spaces.","category":"page"},{"location":"","page":"GeometricFilter.jl","title":"GeometricFilter.jl","text":"A homogeneous space is a manifold mathcalM endowed with a group action from a Lie group G.","category":"page"},{"location":"","page":"GeometricFilter.jl","title":"GeometricFilter.jl","text":"Modules = [GeometricFilter]\nOrder = [:type, :function]","category":"page"},{"location":"#GeometricFilter.ActionObserver","page":"GeometricFilter.jl","title":"GeometricFilter.ActionObserver","text":"ActionObserver(A::AbstractGroupAction{<:ActionDirection}, ref)\n\nModels the observation of a Lie group element χ as the action of χ on some manifold N.\n\nIf it is a left action, the corresponding observation is χ ↦ χ ⋅ x₀, where x₀ ∈ N is a reference point. This often corresponds to a measurement of the state, for instance, the position.\n\nIf it is a right action, the corresponding observation is χ  χ^-1  x₀, where x₀  N is a reference point. This often corresponds to the distance and bearing measurement of a fixed landmark.\n\n\n\n\n\n","category":"type"},{"location":"#GeometricFilter.EmptyObservation","page":"GeometricFilter.jl","title":"GeometricFilter.EmptyObservation","text":"EmptyObservation()\n\nAn empty observation, that is, an observation without any useful information to update the state's uncertainty.\n\n\n\n\n\n","category":"type"},{"location":"#GeometricFilter.IdentityObserver","page":"GeometricFilter.jl","title":"GeometricFilter.IdentityObserver","text":"IdentityObserver(M)\n\nDirect observation of a point on the state manifold.\n\nM = Sphere(2)\nx = rand(M)\nobs = IdentityObserver(M)\nobs(x) # x\n\n\n\n\n\n","category":"type"},{"location":"#GeometricFilter.LinearObserver","page":"GeometricFilter.jl","title":"GeometricFilter.LinearObserver","text":"LinearObserver(H::AbstractMatrix,\n  conv=LeftAction();\n  depth=0)\n\nLinear observation model, x  Hx, or x  xH^*.\n\nH = randn(2,3)\nlobs = LinearObserver(H) # standard linear observer for vectors of size 3\nx = randn(3)\nlobs(x) == H*x # true\n\nA positive depth parameter indicates that the action is on matrices instead of vectors.\n\nH = randn(2,3)\nlobs = LinearObserver(H; depth=4) # standard linear observer for matrices of size 3x4\nx = randn(3,4)\nlobs(x) == H*x # true\n\nThere is a right version as well:\n\nH = randn(2,3)\nlobs = LinearObserver(H, RightAction(); depth=4)\nx = randn(4,3)\nlobs(x) == x*H' # true\n\n\n\n\n\n","category":"type"},{"location":"#GeometricFilter.Observation","page":"GeometricFilter.jl","title":"GeometricFilter.Observation","text":"Observation(observer::Observer, noise::Noise, measurement)\n\nEncapsulation of a full observation data. This includes the actual measurement, but also how it was measured (the observer) and with how much noise. The Observation object is thus built from\n\nan observer (AbstractObserver)\nan observation noise (AbstractNoise)\na measurement, i.e., a point lying on the observer's space\n\n\n\n\n\n","category":"type"},{"location":"#GeometricFilter.ProductObserver-Tuple{Vararg{AbstractObserver}}","page":"GeometricFilter.jl","title":"GeometricFilter.ProductObserver","text":"ProductObserver(observers::AbstractObserver...)\n\nCombine existing observers into a new one.\n\nM = ManifoldsBase.DefaulManifold(2)\n# a simple observer for the sake of this example\nob1 = IdentityObserver(M)\nob2 = IdentityObserver(M)\nx = rand(M) # a point on M\nob = ProductObserver(ob1, ob2)\nob(x) # (x, x)\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.StochasticMotion-Union{Tuple{TA}, Tuple{AffineMotions.AbstractMotion{TA}, ManifoldNormal.AbstractProcessNoise{TA}}} where TA","page":"GeometricFilter.jl","title":"GeometricFilter.StochasticMotion","text":"StochasticMotion(motion::Motion, process_noise::ActionNoise)\n\nEncapsulate the idea of a stochastic dynamical system on a manifold mathcalM, defined by a motion φ colon mathcalMmathfrakg, and a noise model on the manifold.\n\nThe noise process_noise must implement get_lie_covariance_at, so must be of type AbstractActionNoise.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter._predict-Union{Tuple{TA}, Tuple{ManifoldNormal.AbstractProcessDistribution{TA}, AffineMotions.AbstractMotion{TA}}, Tuple{ManifoldNormal.AbstractProcessDistribution{TA}, AffineMotions.AbstractMotion{TA}, Any}} where TA","page":"GeometricFilter.jl","title":"GeometricFilter._predict","text":"_predict(distribution::ActionDistribution, motion::Motion, process_noise::ActionNoise) :: ActionDistribution\n\nUpdates the distribution according to the motion and the process noise.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.add_process_noise-Tuple{ManifoldNormal.AbstractActionDistribution, Any}","page":"GeometricFilter.jl","title":"GeometricFilter.add_process_noise","text":"add_process_noise(dist::AbstractActionDistribution, noise::AbstractActionNoise)\n\n[Deprecated]\n\nAdd process noise to a distribution of type AbstractActionDistribution.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.generate_signal-Tuple{AbstractVector{<:AbstractStochasticMotion}, Any, GeometricFilter.FilteringMode}","page":"GeometricFilter.jl","title":"GeometricFilter.generate_signal","text":"generate_signal(\n  motions::AbstractVector{<:AbstractStochasticMotion}, x0,\n  ::FilteringMode\n)\n\nIntegrate one sample path the sequence of stochastic motions, starting at the point x0.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.generate_signal-Tuple{AbstractVector{<:AffineMotions.AbstractMotion}, Any}","page":"GeometricFilter.jl","title":"GeometricFilter.generate_signal","text":"generate_signal(motions::AbstractVector{<:AbstractMotion}, x0)\n\nIntegrate the sequence of motions, starting at the point x_0.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.get_measurement","page":"GeometricFilter.jl","title":"GeometricFilter.get_measurement","text":"get_measurement(::AbstractObserver, x) :: [point in observation manifold]\n\nThe actual observer function, mapping a point x in the state space to a point in the measurement manifold.\n\n\n\n\n\n","category":"function"},{"location":"#GeometricFilter.get_motion","page":"GeometricFilter.jl","title":"GeometricFilter.get_motion","text":"get_motion(m::AbstractStochasticMotion) :: AbstractMotion\n\nThe underlying deterministic motion.\n\n\n\n\n\n","category":"function"},{"location":"#GeometricFilter.get_noise","page":"GeometricFilter.jl","title":"GeometricFilter.get_noise","text":"get_noise(m::AbstractStochasticMotion) :: AbstractActionNoise\n\nThe underlying process noise.\n\n\n\n\n\n","category":"function"},{"location":"#GeometricFilter.get_tan_observer","page":"GeometricFilter.jl","title":"GeometricFilter.get_tan_observer","text":"get_tan_observer(\n    ::AbstractObserver,\n    A, # group action G ⊂ Diff(M)\n    x, # point in M\n    y=obs(x), # point in N\n) :: Function\n\nReturn the pullback of the tangent map of the observer, that is the function defined by H(ξ) = dh ξx.\n\n\n\n\n\n","category":"function"},{"location":"#GeometricFilter.noisy_observation-Tuple{Random.AbstractRNG, Any, Any, Any}","page":"GeometricFilter.jl","title":"GeometricFilter.noisy_observation","text":"noisy_observation(rng::Random.AbstractRNG,\n  obs::AbstractObserver,\n   noise::AbstractNoise,\n     state)\n\nObservation object encapsulating a noisy version of obs(state).\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.observation_space","page":"GeometricFilter.jl","title":"GeometricFilter.observation_space","text":"observation_space(obs::AbstractObserver) :: AbstractManifold\n\nThe manifold on which the measurement lies.\n\n\n\n\n\n","category":"function"},{"location":"#GeometricFilter.observed_space","page":"GeometricFilter.jl","title":"GeometricFilter.observed_space","text":"observation_space(obs::AbstractObserver) :: AbstractManifold\n\nThe manifold which is observed\n\n\n\n\n\n","category":"function"},{"location":"#GeometricFilter.predict-Tuple{ManifoldNormal.AbstractActionDistribution, Any}","page":"GeometricFilter.jl","title":"GeometricFilter.predict","text":"predict(distribution::AbstractActionDistribution, stochastic_motion::StochasticMotion)\n\nCompute the update of the uncertainty (the distribution), given a motion and its associated process noise (a stochastic motion).\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.rigid_perturbation-Tuple{Random.AbstractRNG, ManifoldNormal.AbstractActionNoise, Any}","page":"GeometricFilter.jl","title":"GeometricFilter.rigid_perturbation","text":"rigid_perturbation(rng::RNG, noise::ActionNoise, x) :: RigidMotion\n\nCompute a random rigid motion using the covariance of the stochastic motion at x, where x is a point on the sample space of the noise.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.sensor_perturbation-Tuple{Random.AbstractRNG, AbstractStochasticMotion, Any}","page":"GeometricFilter.jl","title":"GeometricFilter.sensor_perturbation","text":"sensor_perturbation(rng::RNG, sm::StochasticMotion, x) :: StochasticMotion\n\nSimulate sensor noise by adding a random rigid motion with velocity drawn from the stochastic motions noise.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.simulate-Tuple{AbstractStochasticMotion, Any, GeometricFilter.FilteringMode}","page":"GeometricFilter.jl","title":"GeometricFilter.simulate","text":"simulate(s::StochasticMotion, x::TM,\n  ::FilteringMode,\n  ) ::TM\n\nIntegrate the stochastic motion: deterministically integrate the underlying motion, and adds noise on the result.\n\nThe FilterMode can be the following:\n\nWith DataMode, the motion is integrated exactly.\nWith PositionPerturbation(rng), the noise is added after exact integration.\nWith SensorPerturbation(rng), the noise is applied to the motion, followed by an exact integration.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.simulate_filter-Tuple{ManifoldNormal.AbstractActionDistribution, Any, Any, GeometricFilter.FilteringMode}","page":"GeometricFilter.jl","title":"GeometricFilter.simulate_filter","text":"simulate_filter(\n    ::ActionDistribution,\n    ::Vector{<:StochasticMotion},\n    ::Vector{<:Observation},\n    ::FilteringMode,\n      ) :: Tuple{Vector(Int), Vector(ActionDistribution)}\n\nRuns a simulation of the filter, given a starting distribution,  a vector of stochastic motions, and a vector of observations. Return a dataframe with a column containing the “streak number”, and one column containing the filtered distributions. There are three main mode to use as FilterMode:\n\nDataMode: when it is used with real data\nSensorPerturbation(rng) for simulated perturbation of sensor inputs\nPositionPerturbation(rng) for simulated perturbations of positions\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.simulate_filter_from-Tuple{Any, ManifoldNormal.AbstractActionDistribution, Any, Any}","page":"GeometricFilter.jl","title":"GeometricFilter.simulate_filter_from","text":"simulate_filter(prediction_step,\nD0,\nstochastic_motions,\nobservations)\n\nRun a filter from stochastic motions and observations. The argument prediction_step can be used to modify the standard behaviour of predict, for instance by adding sensor noise, position noise, or both.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.translate_action-Union{Tuple{AD}, Tuple{ActionObserver{AD, TA} where TA<:Manifolds.AbstractGroupAction{AD}, Manifolds.AbstractGroupAction{Manifolds.LeftAction}, Any, Any}} where AD<:Manifolds.ActionDirection","page":"GeometricFilter.jl","title":"GeometricFilter.translate_action","text":"Translate infinitesimal action into the left action of the observation group on itself, in other words, we solve the equation ξχ = ηχ and return η, where  denotes the standard or dual left action of the group on itself.\n\n\n\n\n\n","category":"method"},{"location":"#GeometricFilter.update-Tuple{ManifoldNormal.AbstractActionDistribution, Observation}","page":"GeometricFilter.jl","title":"GeometricFilter.update","text":"update(prior::AbstractActionDistribution, observation::AbstractObservation)\n\nUpdate the uncertainty (the prior) given an observation. Typically, it is used as\n\nupdate(prior, Observation(observer, noise, measurement))\n\nwith a given observer, an associated noise, and a measurement on the observation manifold (the manifold of the observer).\n\n\n\n\n\n","category":"method"}]
}
